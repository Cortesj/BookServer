# |docname| - definition of database models
# *****************************************
# In this file we define our SQLAlchemy data models. These get translated into relational database tables.
#
# Because of the interface with the `databases package <https://www.encode.io/databases/>`_ we will use the `SQLAlchemy core API <https://docs.sqlalchemy.org/en/14/core/>`_
#
# Migrations
# ==========
# We use `Alembic <https://alembic.sqlalchemy.org/en/latest/>`_ for tracking database migration information.
# To create a new migration automatically after you have made changes to this file, run ``alembic revision --autogenerate -m "simple message"``
# this will generate a new file in ``alembic/versions``. To apply changes to the database run ``alembic upgrade head``.
#
# :index:`docs to write`: It is also possible...
#
# Imports
# =======
# These are listed in the order prescribed by `PEP 8`_.
#
# Standard library
# ----------------
# None.
#
# Third-party imports
# -------------------
from sqlalchemy import (
    Column,
    ForeignKey,
    Integer,
    String,
    Date,
    DateTime,
    MetaData,
    Table,
    types,
    Float,
)

# Local application imports
# -------------------------
# None.
from .db import Base


# Web2Py boolean type
# ===================
# Define a web2py-compatible Boolean type. See `custom types <http://docs.sqlalchemy.org/en/latest/core/custom_types.html>`_.
class Web2PyBoolean(types.TypeDecorator):
    impl = types.CHAR(1)

    def process_bind_param(self, value, dialect):
        if value:
            return "T"
        elif value is None:
            return None
        elif not value:
            return "F"
        else:
            assert False

    def process_result_value(self, value, dialect):
        if value == "T":
            return True
        elif value == "F":
            return False
        elif value is None:
            return None
        else:
            assert False

    def copy(self, **kw):
        return Web2PyBoolean(self.impl.length)


# Schema Definition
# =================
# this object is a container for the table objects and can be used by alembic to autogenerate
# the migration information.
metadata = MetaData()


# IdMixin
# -------
# Always name a table's ID field the same way.
class IdMixin:
    id = Column(Integer, primary_key=True)


# Useinfo
# -------
# This defines the useinfo table in the database.  This table logs nearly every click
# generated by a student.  It gets very large and needs a lot of indexes to keep Runestone
# from bogging down.
# Useinfo
# -------
# User info logged by the `hsblog endpoint`. See there for more info.
class Useinfo(Base, IdMixin):
    __tablename__ = "useinfo"
    # _`timestamp`: when this entry was recorded by this webapp.
    timestamp = Column(DateTime)
    # _`sid`: TODO: The student id? (user) which produced this row.
    sid = Column(String(512))
    # The type of question (timed exam, fill in the blank, etc.).
    event = Column(String(512))
    # TODO: What is this? The action associated with this log entry?
    act = Column(String(512))
    # _`div_id`: the ID of the question which produced this entry.
    div_id = Column(String(512))
    # _`course_id`: the Courses ``course_name`` **NOT** the ``id`` this row refers to. TODO: Use the ``id`` instead!
    course_id = Column(String(512), ForeignKey("courses.course_name"))
    chapter = Column(String, unique=False, index=False)
    sub_chapter = Column(String, unique=False, index=False)


# Answer Tables
# -------------
# Each gradable Runestone component has its own answer table.  Most of them are identical.
# This table contains correctness information.
ANSWER_TABLE_NAMES = [
    "mchoice_answers",
    "clickablearea_answers",
    "codelens_answers",
    "dragndrop_answers",
    "fitb_answers",
    "lp_answers",
    "parsons_answers",
    "shortanswer_answers",
    "unittest_answers",
]

answer_columns = [str]

# This should make working with answer tables much easier across the board as we can now just access them by name instead of duplicating code for each case.
answer_tables = {}

for tbl in ANSWER_TABLE_NAMES:
    answer_tables[tbl] = Table(
        tbl,
        metadata,
        Column("id", Integer, primary_key=True, index=True, autoincrement=True),
        Column("timestamp", DateTime, unique=False, index=True),
        Column("sid", String, unique=False, index=True),
        Column(
            "div_id",
            String,
            unique=False,
            index=True,
        ),  # unique identifier for a component
        Column("course_name", String, index=True),
        Column("correct", Web2PyBoolean),
        Column("percent", Float),
        Column("answer", String),
    )

# The parsons_answers table is the only outlier in that it adds a source column to keep
# track of which blocks were not used in the answer.
answer_tables["parsons_answers"] = Table(
    "parsons_answers", metadata, Column("source", String), extend_existing=True
)

# Code
# ----
# The code table captures every run/change of the students code.  It is used to load
# the history slider of the activecode component.
#
code = Table(
    "code",
    metadata,
    Column("id", Integer, primary_key=True, index=True, autoincrement=True),
    Column("timestamp", DateTime, unique=False, index=True),
    Column("sid", String, unique=False, index=True),
    Column(
        "acid",
        String,
        unique=False,
        index=True,
    ),  # unique identifier for a component
    Column("course_name", String, index=True),
    Column("course_id", Integer, index=False),
    Column("code", String, index=False),
    Column("language", String, index=False),
    Column("emessage", String, index=False),
    Column("comment", String, index=False),
)


# Courses
# -------
# Every Course in the runestone system must have an entry in this table
# the id column is really an artifact of the original web2py/pydal implementation of
# Runestone.  The 'real' primary key of this table is the course_name
# Defines either a base course (which must be manually added to the database) or a derived course created by an instructor.
class Courses(Base, IdMixin):
    __tablename__ = "courses"
    # _`course_name`: The name of this course.
    course_name = Column(String(512), unique=True)
    term_start_date = Column(Date)
    # TODO: Why not use base_course_id instead? _`base_course`: the course from which this course was derived. TODO: If this is a base course, this field should be identical to the course_name_?
    base_course = Column(String(512), ForeignKey("courses.course_name"))
    # TODO: This should go in a different table. Not all courses have a Python/Skuplt component.
    login_required = Column(Web2PyBoolean)
    allow_pairs = Column(Web2PyBoolean)
    student_price = Column(Integer)
    downloads_enabled = Column(Web2PyBoolean)
    courselevel = Column(String)

    # # Create ``child_courses`` which all refer to a single ``parent_course``: children's ``base_course`` matches a parent's ``course_name``. See `adjacency list relationships <http://docs.sqlalchemy.org/en/latest/orm/self_referential.html#self-referential>`_.
    # child_courses = relationship(
    #
    #     "Courses", backref=backref("parent_course", remote_side=[course_name])
    # )

    # Define a default query: the username if provided a string. Otherwise, automatically fall back to the id.
    @classmethod
    def default_query(cls, key):
        if isinstance(key, str):
            return cls.course_name == key


class AuthUser(Base, IdMixin):
    __tablename__ = "auth_user"
    username = Column(String(512), nullable=False, unique=True)
    first_name = Column(String(512))
    last_name = Column(String(512))
    email = Column(String(512), unique=True)
    password = Column(String(512))
    created_on = Column(DateTime())
    modified_on = Column(DateTime())
    registration_key = Column(String(512))
    reset_password_key = Column(String(512))
    registration_id = Column(String(512))
    course_id = Column(Integer)
    course_name = Column(String(512))
    active = Column(Web2PyBoolean)
    donated = Column(Web2PyBoolean)
    accept_tcp = Column(Web2PyBoolean)
